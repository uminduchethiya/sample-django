name: Django CI & FTP Deploy - sampleauthapp

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: [3.12]
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v4
        with:
          python-version: ${{ matrix.python-version }}
      
      - name: Install Dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
      
      - name: Run Django Tests
        run: python manage.py test

  deploy:
    needs: build
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: 3.12
      
      - name: Install Dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
      
      - name: Create .htaccess for Django
        run: |
          cat > .htaccess << 'EOF'
          # Django deployment configuration
          DirectoryIndex index.py
          
          # Enable Python CGI
          Options +ExecCGI
          AddHandler cgi-script .py .cgi
          
          # Rewrite rules for Django URLs
          RewriteEngine On
          
          # Serve static files directly
          RewriteCond %{REQUEST_FILENAME} -f
          RewriteRule ^.*$ - [L]
          
          # Route everything else to Django
          RewriteCond %{REQUEST_FILENAME} !-f
          RewriteCond %{REQUEST_FILENAME} !-d
          RewriteRule ^(.*)$ /index.py/$1 [L,QSA]
          
          # Security - hide Python files from direct access
          <Files "manage.py">
              Order allow,deny
              Deny from all
          </Files>
          
          <Files "*.pyc">
              Order allow,deny
              Deny from all
          </Files>
          
          <Files "requirements.txt">
              Order allow,deny
              Deny from all
          </Files>
          
          # Cache static files
          <FilesMatch "\.(css|js|png|jpg|jpeg|gif|ico|svg)$">
              ExpiresActive On
              ExpiresDefault "access plus 1 year"
          </FilesMatch>
          EOF
      
      - name: Create Django CGI entry point
        run: |
          cat > index.py << 'EOF'
          #!/usr/bin/env python3
          
          import os
          import sys
          import cgitb
          
          # Enable CGI error reporting
          cgitb.enable()
          
          # Add current directory to Python path
          sys.path.insert(0, os.path.dirname(__file__))
          
          # Set Django settings
          os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'sampleauthapp.settings')
          
          try:
              import django
              django.setup()
              
              from django.core.handlers.wsgi import WSGIHandler
              from django.core.management import execute_from_command_line
              from django.http import HttpResponse
              from django.conf import settings
              import urllib.parse
              
              # Simple CGI to WSGI adapter
              def simple_cgi():
                  # Parse the request
                  method = os.environ.get('REQUEST_METHOD', 'GET')
                  path_info = os.environ.get('PATH_INFO', '/')
                  query_string = os.environ.get('QUERY_STRING', '')
                  
                  # Remove /index.py from path if present
                  if path_info.startswith('/index.py'):
                      path_info = path_info[9:]  # Remove '/index.py'
                  
                  if not path_info:
                      path_info = '/'
                  
                  # Set up WSGI environ
                  environ = {
                      'REQUEST_METHOD': method,
                      'PATH_INFO': path_info,
                      'QUERY_STRING': query_string,
                      'CONTENT_TYPE': os.environ.get('CONTENT_TYPE', ''),
                      'CONTENT_LENGTH': os.environ.get('CONTENT_LENGTH', ''),
                      'SERVER_NAME': os.environ.get('SERVER_NAME', 'localhost'),
                      'SERVER_PORT': os.environ.get('SERVER_PORT', '80'),
                      'HTTP_HOST': os.environ.get('HTTP_HOST', 'localhost'),
                      'wsgi.version': (1, 0),
                      'wsgi.url_scheme': 'http',
                      'wsgi.input': sys.stdin.buffer if hasattr(sys.stdin, 'buffer') else sys.stdin,
                      'wsgi.errors': sys.stderr,
                      'wsgi.multithread': False,
                      'wsgi.multiprocess': True,
                      'wsgi.run_once': True,
                  }
                  
                  # Add HTTP headers to environ
                  for key, value in os.environ.items():
                      if key.startswith('HTTP_'):
                          environ[key] = value
                  
                  # Get Django WSGI application
                  from django.core.wsgi import get_wsgi_application
                  application = get_wsgi_application()
                  
                  # Capture response
                  response_data = []
                  response_status = None
                  response_headers = []
                  
                  def start_response(status, headers, exc_info=None):
                      nonlocal response_status, response_headers
                      response_status = status
                      response_headers = headers
                  
                  # Get response from Django
                  response = application(environ, start_response)
                  
                  # Output HTTP response
                  print(f"Status: {response_status}")
                  for header_name, header_value in response_headers:
                      print(f"{header_name}: {header_value}")
                  print()  # Empty line between headers and content
                  
                  # Output response content
                  if hasattr(response, '__iter__'):
                      for data in response:
                          if data:
                              sys.stdout.buffer.write(data)
                  
              if __name__ == '__main__':
                  simple_cgi()
                  
          except ImportError as e:
              print("Content-Type: text/html")
              print()
              print(f"<h1>Django Import Error</h1><p>{e}</p>")
              
          except Exception as e:
              print("Content-Type: text/html")
              print()
              print(f"<h1>Error</h1><p>{e}</p>")
              print(f"<p>Path: {os.environ.get('PATH_INFO', 'Unknown')}</p>")
          EOF
          
          chmod +x index.py
      
      - name: FTP Deploy
        uses: SamKirkland/FTP-Deploy-Action@v4.3.4
        with:
          server: ${{ secrets.FTP_SERVER }}
          username: ${{ secrets.FTP_USERNAME }}
          password: ${{ secrets.FTP_PASSWORD }}
          protocol: ftp
          port: 21
          local-dir: ./
          server-dir: /public_html/
          exclude: |
            **/.git*
            **/.github*
            **/venv/**
            **/__pycache__/**
            **/*.pyc
            **/*.pyo
            **/*.log
            **/.env*
            **/.DS_Store
            **/db.sqlite3*
            **/tests.py
            **/test_*.py
          log-level: verbose
